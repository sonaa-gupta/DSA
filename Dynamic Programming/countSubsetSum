class Solution {
    // Function to calculate the number of subsets with a given sum
    public int perfectSum(int[] nums, int target) {
        // code here
        return countSubset(nums, nums.length-1, target);
    }
    
    public static int countSubset(int[] nums,int ind, int target){
        if(ind == 0){
           if(nums[0] == 0 && target == 0) return 2 ; // for edge casee like {0} tar = 0 then we have count as 2 because {},{0}
           if(target == 0 || nums[0] == target) return 1;
           return 0;
        }
        
        int notPick = countSubset(nums,ind-1,target);
        int pick =0;
        if(nums[ind]<= target) 
        pick = countSubset(nums,ind-1,target-nums[ind]);
        return pick+notPick;
    }
}

// DP memoization
class Solution {
    // Function to calculate the number of subsets with a given sum
    public int perfectSum(int[] nums, int target) {
        // code here
        int dp[][] = new int[nums.length][target+1];
        for (int i = 0; i < nums.length; i++) {
    Arrays.fill(dp[i], -1);
}
        return countSubset(nums, nums.length-1, target, dp);
    }
    
    public static int countSubset(int[] nums,int ind, int target,  int dp[][]){
        if(ind == 0){
           if(nums[0] == 0 && target == 0) return 2 ; // for edge casee like {0} tar = 0 then we have count as 2 because {},{0}
           if(target == 0 || nums[0] == target) return 1;
           return 0;
        }
        if(dp[ind][target] != -1) return dp[ind][target];
        int notPick = countSubset(nums,ind-1,target,dp);
        int pick =0;
        if(nums[ind]<= target) 
        pick = countSubset(nums,ind-1,target-nums[ind],dp);
        return dp[ind][target]=pick+notPick;
    }
}

// Tabulation----------
class Solution {
    // Function to calculate the number of subsets with a given sum
    public int perfectSum(int[] nums, int sum) {
        // code here
        int dp[][] = new int[nums.length][sum+1];
        for (int i = 0; i < nums.length; i++) {
        Arrays.fill(dp[i], 0);
}
      if(nums[0]==0) dp[0][0] =2;
      else dp[0][0] =1;
      
      if(nums[0] != 0 && nums[0] <= sum) dp[0][nums[0]] = 1;
      
      
       for(int ind= 1;ind<nums.length;ind++)
       {
           for(int target= 0;target<=sum; target++)
           {
               int notPick = dp[ind-1][target];
               int pick =0;
               if(nums[ind]<=target)
               pick = dp[ind-1][target-nums[ind]];
               dp[ind][target] = pick+notPick;
           }
       }
      return dp[nums.length-1][sum];
    }
}